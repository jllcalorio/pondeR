power      = 0.80,
alpha      = 0.05,
tails      = c("two", "one")[1]
)
gpower_logistic_n_binomial_exact <- function(
odds_ratio,
p0 = 0.5,
theta = 0.5,
R2_other_X = 0,
power = 0.80,
alpha = 0.05,
tails = c("two", "one")
) {
tails <- match.arg(tails)
beta1 <- log(odds_ratio)
# ---- variance of X ----
var_x <- theta * (1 - theta)
# ---- critical z ----
zcrit <- if (tails == "two") qnorm(1 - alpha / 2) else qnorm(1 - alpha)
# ---- exact expected pq for binary X ----
p1 <- p0 * exp(beta1) / (1 - p0 + p0 * exp(beta1))
avg_pq <- (1 - theta) * p0 * (1 - p0) + theta * p1 * (1 - p1)
for (N in 4:1e6) {
var_beta <- 1 / (N * var_x * avg_pq)
var_beta <- var_beta / (1 - R2_other_X)
z <- beta1 / sqrt(var_beta)
achieved_power <- if (tails == "two") {
pnorm(-zcrit, mean = z) + (1 - pnorm(zcrit, mean = z))
} else {
1 - pnorm(zcrit, mean = z)
}
if (achieved_power >= power) {
return(list(
N = N,
beta = beta1,
var_beta = var_beta,
z = z,
achieved_power = achieved_power
))
}
}
stop("Required sample size exceeds n_max")
}
gpower_logistic_n_binomial(
odds_ratio = 1.3,
p0         = 0.2,
theta      = 0.5,          # probability for X=1
R2_other_X = 0,
power      = 0.80,
alpha      = 0.05,
tails      = c("two", "one")[1]
)
gpower_logistic_n_binomial(
odds_ratio = 1.3,
p0         = 0.2,
theta      = 0.5,          # probability for X=1
R2_other_X = 0,
power      = 0.80,
alpha      = 0.05,
tails      = c("two", "one")[1]
)
gpower_logistic_n_binomial(
odds_ratio = 1.3,
p0         = 0.2,
theta      = 0.5,          # probability for X=1
R2_other_X = 0,
power      = 0.80,
alpha      = 0.05,
tails      = c("two", "one")[1]
)
gpower_logistic_n_binomial_exact <- function(
odds_ratio,
p0 = 0.5,
theta = 0.5,
R2_other_X = 0,
power = 0.80,
alpha = 0.05,
tails = c("two", "one")
) {
tails <- match.arg(tails)
beta1 <- log(odds_ratio)
# ---- variance of X ----
var_x <- theta * (1 - theta)
# ---- critical z ----
zcrit <- if (tails == "two") qnorm(1 - alpha / 2) else qnorm(1 - alpha)
# ---- exact expected pq for binary X ----
p1 <- p0 * exp(beta1) / (1 - p0 + p0 * exp(beta1))
avg_pq <- (1 - theta) * p0 * (1 - p0) + theta * p1 * (1 - p1)
for (N in 4:1e6) {
var_beta <- 1 / (N * var_x * avg_pq)
var_beta <- var_beta / (1 - R2_other_X)
z <- beta1 / sqrt(var_beta)
achieved_power <- if (tails == "two") {
pnorm(-zcrit, mean = z) + (1 - pnorm(zcrit, mean = z))
} else {
1 - pnorm(zcrit, mean = z)
}
if (achieved_power >= power) {
return(list(
N = N,
beta = beta1,
var_beta = var_beta,
z = z,
achieved_power = achieved_power
))
}
}
stop("Required sample size exceeds n_max")
}
gpower_logistic_n_binomial_exact(
odds_ratio = 1.3,
p0         = 0.2,
theta      = 0.5,
R2_other_X = 0,
power      = 0.80,
alpha      = 0.05,
tails      = c("two", "one")[1]
)
gpower_logistic_n_binomial_analytic <- function(
odds_ratio,
p0 = 0.5,
theta = 0.5,          # probability of X=1
R2_other_X = 0,
power = 0.80,
alpha = 0.05,
tails = c("two", "one")
) {
tails <- match.arg(tails)
beta1 <- log(odds_ratio)
# ---- variance of binary X ----
var_x <- theta * (1 - theta)
# ---- critical z ----
zcrit <- if (tails == "two") qnorm(1 - alpha / 2) else qnorm(1 - alpha)
zpower <- qnorm(power)
# ---- exact probabilities ----
p1 <- p0 * odds_ratio / (1 - p0 + p0 * odds_ratio)
avg_pq <- (1 - theta) * p0 * (1 - p0) + theta * p1 * (1 - p1)
# ---- analytic N ----
N_exact <- ((zcrit + zpower)^2) / (beta1^2 * var_x * avg_pq)
N_exact <- N_exact / (1 - R2_other_X)
N <- ceiling(N_exact)  # round up to nearest integer
# ---- compute other outputs ----
var_beta <- 1 / (N * var_x * avg_pq)
var_beta <- var_beta / (1 - R2_other_X)
z <- beta1 / sqrt(var_beta)
achieved_power <- if (tails == "two") {
pnorm(-zcrit, mean = z) + (1 - pnorm(zcrit, mean = z))
} else {
1 - pnorm(zcrit, mean = z)
}
return(list(
N = N,
beta = beta1,
var_beta = var_beta,
z = z,
achieved_power = achieved_power
))
}
gpower_logistic_n_binomial_analytic(
odds_ratio = 1.3,
p0 = 0.2,
theta = 0.5,
power = 0.80,
alpha = 0.05,
tails = "two"
)
gpower_logistic_n_binomial_exact(
odds_ratio = 1.3,
p0         = 0.2,
theta      = 0.5,
R2_other_X = 0,
power      = 0.80,
alpha      = 0.05,
tails      = c("two", "one")[1]
)
gpower_logistic_n_binomial <- function(
odds_ratio,
p0 = 0.5,
theta = 0.5,          # probability of X=1
R2_other_X = 0,
power = 0.80,
alpha = 0.05,
tails = c("two", "one")
) {
tails <- match.arg(tails)
beta1 <- log(odds_ratio)
# ---- variance of binary X ----
var_x <- theta * (1 - theta)
# ---- critical z ----
zcrit <- if (tails == "two") qnorm(1 - alpha / 2) else qnorm(1 - alpha)
zpower <- qnorm(power)
# ---- exact probabilities ----
p1 <- p0 * odds_ratio / (1 - p0 + p0 * odds_ratio)
avg_pq <- (1 - theta) * p0 * (1 - p0) + theta * p1 * (1 - p1)
# ---- analytic N ----
N_exact <- ((zcrit + zpower)^2) / (beta1^2 * var_x * avg_pq)
N_exact <- N_exact / (1 - R2_other_X)
N <- ceiling(N_exact)  # round up to nearest integer
# ---- compute other outputs ----
var_beta <- 1 / (N * var_x * avg_pq)
var_beta <- var_beta / (1 - R2_other_X)
z <- beta1 / sqrt(var_beta)
achieved_power <- if (tails == "two") {
pnorm(-zcrit, mean = z) + (1 - pnorm(zcrit, mean = z))
} else {
1 - pnorm(zcrit, mean = z)
}
return(list(
N = N,
beta = beta1,
var_beta = var_beta,
z = z,
achieved_power = achieved_power
))
}
gpower_logistic_n_binomial(
odds_ratio = 1.3,
p0         = 0.2,
theta      = 0.5,
R2_other_X = 0,
power      = 0.80,
alpha      = 0.05,
tails      = c("two", "one")[1]
)
gpower_logistic_n_binomial_exact(
odds_ratio = 1.3,
p0         = 0.2,
theta      = 0.5,
R2_other_X = 0,
power      = 0.80,
alpha      = 0.05,
tails      = c("two", "one")[1]
)
gpower_logistic_n_binomial <- function(
odds_ratio,
p0 = 0.5,
theta = 0.5,          # probability of X=1
R2_other_X = 0,
power = 0.80,
alpha = 0.05,
tails = c("two", "one")
) {
tails <- match.arg(tails)
beta1 <- log(odds_ratio)
# ---- variance of binary X ----
var_x <- theta * (1 - theta)
# ---- critical z ----
zcrit <- if (tails == "two") qnorm(1 - alpha / 2) else qnorm(1 - alpha)
zpower <- qnorm(power)
# ---- exact probabilities ----
p1 <- p0 * odds_ratio / (1 - p0 + p0 * odds_ratio)
avg_pq <- (1 - theta) * p0 * (1 - p0) + theta * p1 * (1 - p1)
# ---- analytic N ----
N_exact <- ((zcrit + zpower)^2) / (beta1^2 * var_x * avg_pq)
N_exact <- N_exact / (1 - R2_other_X)
N <- ceiling(N_exact)  # round up to nearest integer
# ---- compute other outputs ----
var_beta <- 1 / (N * var_x * avg_pq)
var_beta <- var_beta / (1 - R2_other_X)
z <- beta1 / sqrt(var_beta)
achieved_power <- if (tails == "two") {
pnorm(-zcrit, mean = z) + (1 - pnorm(zcrit, mean = z))
} else {
1 - pnorm(zcrit, mean = z)
}
return(list(
N = N,
beta = beta1,
var_beta = var_beta,
z = z,
achieved_power = achieved_power
))
}
gpower_logistic_n_binomial(
odds_ratio = 1.3,
p0         = 0.2,
theta      = 0.5,
R2_other_X = 0,
power      = 0.80,
alpha      = 0.05,
tails      = c("two", "one")[1]
)
cohen_w <- function(p_obs, p_exp) {
sqrt(sum((p_obs - p_exp)^2 / p_exp))
}
gpower_chisq_n <- function(w,
df,
power = 0.80,
alpha = 0.05,
n_min = 5,
n_max = 1e6) {
f <- function(N) {
lambda <- N * w^2
crit <- .gpower_crit(alpha, df1 = df, test = "chisq")
.gpower_power(crit, df1 = df, ncp = lambda,
test = "chisq") - power
}
ceiling(uniroot(f, c(n_min, n_max))$root)
}
gpower_chisq_n(
w = .3,
df = 5,
power = 0.80,
alpha = 0.05,
n_min = 5,
n_max = 1e6
)
gpower_chisq_n(
w = .3,
df = 8,
power = 0.80,
alpha = 0.05,
n_min = 5,
n_max = 1e6
)
gpower_chisq_n <- function(w,
df,
power = 0.80,
alpha = 0.05,
n_min = 5,
n_max = 1e6) {
# function to find N
f <- function(N) {
lambda <- N * w^2
crit <- .gpower_crit(alpha, df1 = df, test = "chisq")
.gpower_power(crit, df1 = df, ncp = lambda, test = "chisq") - power
}
# solve for N
N <- ceiling(uniroot(f, c(n_min, n_max))$root)
# compute additional outputs
lambda <- N * w^2
crit <- .gpower_crit(alpha, df1 = df, test = "chisq")
achieved_power <- .gpower_power(crit, df1 = df, ncp = lambda, test = "chisq")
return(list(
N = N,
lambda = lambda,
crit = crit,
achieved_power = achieved_power
))
}
gpower_chisq_n(
w = .3,
df = 8,
power = 0.80,
alpha = 0.05,
n_min = 5,
n_max = 1e6
)
p_obs <- c(0.6, 0.4)
p_exp <- c(0.5, 0.5)
w <- cohen_w(p_obs, p_exp)
w
cohen_w <- function(p_obs, p_exp) {
# Convert to numeric vectors
p_obs <- as.numeric(p_obs)
p_exp <- as.numeric(p_exp)
# Normalize if sum != 1
if (abs(sum(p_obs) - 1) > 1e-6) {
p_obs <- p_obs / sum(p_obs)
}
if (abs(sum(p_exp) - 1) > 1e-6) {
p_exp <- p_exp / sum(p_exp)
}
# Compute Cohen's w
sqrt(sum((p_obs - p_exp)^2 / p_exp))
}
p_obs <- c(0.6, 0.4)
p_exp <- c(0.5, 0.5)
w <- cohen_w(p_obs, p_exp)
w
p_obs <- c(60, 40)
p_exp <- c(50, 50)
w <- cohen_w(p_obs, p_exp)
w
# [1] 0.2
p_obs <- c(0.4, 0.3, 0.2, 0.1)
p_exp <- c(0.25, 0.25, 0.25, 0.25)
w <- cohen_w(p_obs, p_exp)
w
# [1] 0.2738613
cohen_w <- function(p_obs, p_exp) {
# Ensure input are numeric
p_obs <- as.numeric(p_obs)
p_exp <- as.numeric(p_exp)
# Check that they are percentages (sum ~100)
if (abs(sum(p_obs) - 100) > 1e-6) {
stop("p_obs must be percentages that sum to 100")
}
if (abs(sum(p_exp) - 100) > 1e-6) {
stop("p_exp must be percentages that sum to 100")
}
# Convert to proportions
p_obs <- p_obs / 100
p_exp <- p_exp / 100
# Compute Cohen's w
sqrt(sum((p_obs - p_exp)^2 / p_exp))
}
p_obs <- c(60, 40)
p_exp <- c(50, 50)
w <- cohen_w(p_obs, p_exp)
w
# [1] 0.2041241
p_obs <- c(40, 30, 20, 10)
p_exp <- c(25, 25, 25, 25)
w <- cohen_w(p_obs, p_exp)
w
# [1] 0.2738613
# Example proportions
p0 <- c(0.25, 0.25, 0.25, 0.25)   # Null hypothesis proportions
p1 <- c(0.10, 0.20, 0.30, 0.40)   # Alternative hypothesis proportions
# Calculate effect size w
effect_size_w <- sqrt(sum((p1 - p0)^2 / p0))
effect_size_w
cohen_w(p0, p1)
p0
p1
sum(0)
sum(p0)
sum(p1)
cohen_w <- function(p_obs, p_exp) {
sqrt(sum((p_obs - p_exp)^2 / p_exp))
}
cohen_w(p0, p1)
cohen_w(p0, p1)
sqrt(sum((p_exp - p_obs)^2 / p_obs))
cohen_w <- function(p_obs, p_exp) {
sqrt(sum((p_exp - p_obs)^2 / p_obs))
}
cohen_w(p0, p1)
p_obs
p0
cohen_w <- function(p_null, p_alternative) {
sqrt(sum((p_alternative - p_null)^2 / p_null))
}
cohen_w(p0, p1)
w <- cohen_w(p0, p1)
gpower_chisq_n(
w = w,
df = 8,
power = 0.80,
alpha = 0.05,
n_min = 5,
n_max = 1e6
)
cohen_f_from_eta2 <- function(eta2) {
sqrt(eta2 / (1 - eta2))
}
gpower_anova_oneway_n <- function(f,
k,
power = 0.80,
alpha = 0.05,
n_min = k + 1,
n_max = 1e6) {
f_root <- function(N) {
df1 <- k - 1
df2 <- N - k
lambda <- f^2 * N
crit <- .gpower_crit(alpha, df1, df2, test = "f")
.gpower_power(crit, df1, df2, lambda,
test = "f") - power
}
ceiling(uniroot(f_root, c(n_min, n_max))$root)
}
f2_from_R2 <- function(R2) {
R2 / (1 - R2)
}
gpower_lm_R2_n <- function(R2,
u,
power = 0.80,
alpha = 0.05,
n_max = 1e6) {
if (R2 <= 0 || R2 >= 1)
stop("R2 must be between 0 and 1")
if (u < 1 || u %% 1 != 0)
stop("u must be a positive integer")
f2 <- f2_from_R2(R2)
for (N in (u + 2):n_max) {
df1 <- u
df2 <- N - u - 1
if (df2 <= 0) next
lambda <- f2 * N   # ðŸ”‘ G*Power definition
crit <- qf(1 - alpha, df1, df2)
achieved_power <- 1 - pf(crit, df1, df2, ncp = lambda)
if (achieved_power >= power) {
return(list(
N = N,
df1 = df1,
df2 = df2,
critical_F = crit,
lambda = lambda,
achieved_power = achieved_power
))
}
}
stop("Required sample size exceeds n_max")
}
gpower_lm_R2_n(
.8,
u=2,
power = 0.80,
alpha = 0.05,
# n_min = u + 2,
n_max = 1e6
)
gpower_lm_R2_n(
.8,
u=7,
power = 0.80,
alpha = 0.05,
# n_min = u + 2,
n_max = 1e6
)
